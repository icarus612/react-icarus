{"ast":null,"code":"var animateBG = (el, colors, t) => {\n  let animation = [];\n\n  for (let i = 0; i < colors.length; i++) {\n    let j = i + 1;\n    animation[animation.length] = anime({\n      targets: el,\n      backgroundColor: [colors[i], colors[j] || colors[0]],\n      easing: \"linear\",\n      duration: t,\n      autoplay: false,\n      complete: function (anim) {\n        animation[j < colors.length ? j : 0].play();\n      }\n    });\n  }\n\n  return animation[0].play();\n};\n\nvar scrollBG = (el, colors, t) => {\n  let animation = [];\n\n  for (let i = 0; i < colors.length; i++) {\n    let j = i + 1;\n    animation[animation.length] = anime({\n      targets: el,\n      backgroundColor: [colors[i], colors[j] || colors[0]],\n      easing: \"linear\",\n      duration: t,\n      delay: t * i,\n      autoplay: false\n    });\n  }\n\n  window.onscroll = () => {\n    let x = Math.floor(animation[animation.length - 1].currentTime / t);\n    let y = Math.floor(animation[animation.length - 1].currentTime);\n\n    for (i = 0; i < animation.length; i++) {\n      animation[i].seek(window.scrollY / t * animation[i].duration);\n    }\n\n    return animation[x].seek(window.scrollY / t * animation[animation.length - 1].duration);\n  };\n\n  return animation[0].seek(1);\n};","map":{"version":3,"sources":["/Users/ellis/git/github/react-icarus/src/assets/js/colorChanger.js"],"names":["animateBG","el","colors","t","animation","i","length","j","anime","targets","backgroundColor","easing","duration","autoplay","complete","anim","play","scrollBG","delay","window","onscroll","x","Math","floor","currentTime","y","seek","scrollY"],"mappings":"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","sourcesContent":["var animateBG = (el, colors, t) =>{\n    let animation = [];\n    for (let i = 0; i < colors.length; i++){\n        let j = i + 1\n        animation[animation.length] = anime({\n            targets: el,\n            backgroundColor: [colors[i], colors[j] || colors[0]],\n            easing: \"linear\",\n            duration: t,\n            autoplay: false,\n            complete: function(anim){\n                animation[j < colors.length ? j : 0].play();\n            }\n        })\n    }\n    return animation[0].play()\n    \n}\nvar scrollBG = (el, colors, t) => {\n    let animation = [];\n    for (let i = 0; i < colors.length; i++){\n        let j = i + 1\n        animation[animation.length] = anime({\n            targets: el,\n            backgroundColor: [colors[i], colors[j] || colors[0]],\n            easing: \"linear\",\n            duration: t,\n            delay: t * i,\n            autoplay: false,\n        })\n    }\n    window.onscroll = () => {\n        let x = Math.floor(animation[animation.length-1].currentTime/t)\n        let y = Math.floor(animation[animation.length-1].currentTime)\n    \n        for (i = 0; i < animation.length; i++){\n            animation[i].seek((window.scrollY / t) * animation[i].duration);\n        }\n        return animation[x].seek((window.scrollY / t) * animation[animation.length-1].duration);\n    };\n    return animation[0].seek(1)\n \n}\n"]},"metadata":{},"sourceType":"module"}